# 소프트웨어 설계

객체지향 분석 방법론

1. 럼바우 방법론 (OMT)
가장 일반적으로 사용되고 객체모델, 동적모델, 기능모델로 나누어 수행하는 방법.
모든 SW 구성 요소를 그래픽 표기법으로 활용하여 모델링하여 시스템 개발의 전 단계가 추상화, 캡슐화, 상속성 등 일관된 객체지향
개념이 적용되는 객체지향 개발 방법.
분석절차 : 객체 -> 동적 -> 기능
객체 모델링 : 객체 다이어그램
동적 모델링 : 상태도 (상태 다이어그램)
기능 모델링 : 자료 흐름도

2. 부치 방법론
미시적 개발 프로세스와 거시적 개발 프로세스 모두 포함하여 사용.
클래스와 객체들 분석 및 식별하고 클래스 속성과 연산 정의
클래스와 객체 의미 식별, 클래스와 객체들 관계 식별, 클래스와 객체 구현

3. 코드와 요든 방법론
E-R 다이어그램 이용하여 객체의 행위를 모델링하며 객체식별, 구조 식별,
주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성.

4. 워프스-브록 방법론
분석과 설계 간 구분이 없어 설계 작업까지 연속적으로 수행

Pareto의 법칙
소프트 웨어 테스트에서 오류의 80퍼센트는 전체의 20퍼센트에서 발견된다

Brooks의 법칙
지연되는 프로젝트에 인력을 더 투입하면 오히려 더 늦어진다.

Paradox의 법칙
동일 테스트 케이스로 동일 테스트 반복 시 결함이 발견되지 않는 현상.

응집도 :
1. 모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도
2. 정보 은닉 개념의 확장 개념으로 하나의 모듈은 하나의 기능을 수행한다.

응집도 순서 ( a < b )
우연적(coincidental) 논리적(Logical) 시간적(Temporal) 절차적(Procedural) 교환적(Communication) 순차적(Sequential) 기능적(Functional)


결합도 :
1. 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호 의존성을 나타내는 정도.

결합도 순서 ( a < b )
자료(Data) 스탬프(Stamp) 제어(control) 외부(External) 공통(Common) 내용(Content)

소프트웨어 생명주기 모델
1. 폭포수 모형
고전적 생명 주기 모형이고 선형 순차적 모형.
단계별 정의 및 산출물이 명확 -> 개발 중간에 요구사항의 변경이 용이하지 않다.

2. 프로토타입 모형
견본품을 만들어 최종 결과물을 예측하는 모형.
인터페이스 중점 개발이라 개발 중간에 요구사항의 변경에 용이

3. 나선형 모형
위의 두 모형 (폭포수, 프로토타입)의 장점에 위험 분석 기능을 추가한 모형
점진적 개발 과정 반복으로 요구사항 추가 기능 -> 정밀하고 유지보수 과정 필요 없음.
계획 -> 위험 분석 -> 개발 -> 고객 평가

4. 애자일 모형
애자일은 민첩함, 기민함 의미 -> 변화에 유연하게 대응
일정 주기 반복하면서 개발 진행.
절차와 도구보다 고객(개인)과의 소통에 초점을 맞춤.
ex) XP(eXtreme Programming), 스크럼(Scrum), 칸반(Kanban), 크리스탈(Krystal), 린(Lean) 
+ 기능 중심 개발
XP 의 핵심 가치 : 용기, 단순성, 의사소통, 피드백, 존중
  기본 원리: 
  
요구사항 분석 기법
1. 요구사항 분류
2. 요구사항 할당
3. 요구사항 협상
4. 개념 모델링
5. 정형 분석

요구사항 확인 기법
1. 요구사항 검토
2. 프로토타이핑
3. 모델 검증
4. 인수 테스트(알파 테스트, 베타 테스트)
알파 테스트 : 인수 테스트 후 베타 테스트 전에 하는 사내 마지막 테스트
베타 테스트 : 실제 환경에서 실제 사용자가 수행한 테스트 -> 게임 베타테스터 생각하면 쉬움.

UML (Unified Modeling Language)의 구성 요소
사물, 관계, 다이어그램(동적 ,정적)

UI (User Interface)
cli, gui, nui, vui, oui

UI의 기본 원칙
1. 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야함.
2. 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함.
3. 학습성 : 누구나 쉽게 배우고 익힐 수 있어야함.
4. 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함.

UI 설계 도구
와이어 프레임, 스토리보드, 프로토타입, 목업, 유스케이스

UI 시나리오 문서 요건
이해성, 완전성, 일관성, 가독성, 수정 용이성, 추적 용이성

소프트웨어 아키텍처
1. 모듈화
2. 추상화
3. 단계적 분해
4. 정보 은닉

아키텍처 패턴
1. 레이어 패턴
2. 클라이언트-서버 패턴
3. 파이프-필터 패턴
4. 모델 뷰 컨트롤러(MVC) 패턴
5. 마스터-슬레이브 패턴
6. 브로커 패턴
7. 피어-투-피어 패턴
8. 이벤트-버스 패턴
9. 블랙보드 패턴
10. 인터프리터 패턴

소프트웨어 아키텍쳐 뷰
1. 유스케이스 뷰 
2. 논리 뷰
3. 프로세스 뷰
4. 구현 뷰
5. 배포 뷰

공통 모듈
정확성, 명확성, 완전성, 일관성, 추적성, 재사용 규모에 따른 분류

코드
1. 순차(순서)코드 (sequence 일련 번호 코드) : 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법
2. 블록 코드(Block Code, 구분 코드) : 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법.
3. 10진 코드(Decimal Code, 도서 분류식 코드) : 0~9까진 10진분할하고, 다시 각각에 대해서 10진 분할하는 방법. ex) 1000,1100,1110
4. 그룹 분류코드 : 대분류,중분류,소분류 등으로 구분하고 각 그룹안에서 일련번호 부여
5. 연상코드 : 관계있는 숫자나 문자, 기호를 이용하여 코드 부여.
6. 표의 숫자코드 (유효 숫자 코드) : 물리적 수치를 그대로 코드에 적용.
7. 합성 코드 : 2개 이상의 코드를 조합하여 만드는 방법.
8. 코드 부여 체계 : 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식.

디자인패턴

생성 패턴
1. 추상 팩토리
2. 팩토리 메소드
3. 빌더
4. 프로토타입
5. 싱글톤

구조 패턴
1. 어댑터
2. 브리지
3. 컴포지트
4. 데코레이터
5. 퍼싸드
6. 플라이웨이트
7. 프록시

행위 패턴
1. 책임 연쇄
2. 커맨드
3. 인터프리터
4. 반복자
5. 중재자
6. 메멘토
7. 옵서버
8. 상태
9. 전략
10. 템플릿 메소드
11. 방문자

인터페이스 요구사항 검증
요구사항 검토 계획 수립 -> 검토 및 오류 수정 -> 베이스라인 설정

요구사항 검증 방법
1. 동료 검토 : 작성자가 내용을 직접 설명하고 동료들이 이를 들으며 결함을 발견하는 검토방법.
2. 워크 스루 : 검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검투한 후, 짧은 검토 회의를 통해 결함을 발견하는 방법.
3. 인스펙션 : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견하는 방법.

검증 주요 항목
기능성, 완전성, 일관성, 명확성, 변경 용이성, 검증 가능성, 추적 가능성

인터페이스 식별 : 인터페이스 요구사항 명세서와 인터페이스 요구사항 목록을 기반으로 인터페이스 목록을 작성하는 것.
인터페이스 시스템 식별: 송신 시스템과 수신 시스템으로 구분하여 작성하는 것.

인터페이스 표준 항목
1. 시스템 공통부: 시스템 간 연동 시 필요한 공통 정보 ex) ID, 서비스 코드, 응답 결과, 장애, 전송 시스템
2. 거래 공통부: 시스템들이 연동된 후 송,수신 되는 데이터를 처리할 때 필요한 정보. ex) 직원 정보, 승인자 정보, 기기 정보, 매체 정보

미들웨어 솔루션 명세
운영체제와 해당 운영체제에서 실행되는 응용프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
1. DB 클라이언트에서 데이터베이스와 연결하기 위한 미들웨어 ex) ODBC, IDAPI, Glue(Oracle)
2. RPC Remote Procedure Call 응용프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어
3. MOM Message Oriented Middleware 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
4. TP-Monitor Transaction Processing Monitor 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어, 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 이용됨.
5. Legacyware 기존 어플리케이션에 새로운 업데이트된 기능을 덧붙이고자 할 때 사용됨.
6. ORB Object Request Broker 객체지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어, 네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격을 의미
7. WAS Web Application Server 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어, 웹 환경을 구현하기 위한 미들웨어

CASE Computer Aided Software Engineering 도구의 분류
상위 CASE : 계획수립, 요구분석, 기본설계 단계를 다이어그램으로 표현 ex) 모순검사, 오류검증, 자료흐름도 작성 지원
중위 CASE : 상세 설계작업, 화면 출력 작성 지원
하위 CASE : 시스템, 명세서, 소스 코드 생성 지원
