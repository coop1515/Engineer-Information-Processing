자료구조의 분류
선형 구조
1. 배열 : 정적인 자료구조, 기억장소의 추가가 어렵고 메모리 낭비 발생, 반복적 데이터 처리에 적합. 동일한 이름의 변수 사용.
2. 스택 LIFO : 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어짐.
3. 큐 FIFO : 한 쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이루워짐.
4. 데크 : 리스트의 양쪽 끝에서 삽입과 삭제 작업 가능.
5. 선형리스트 = 연속 리스트(순차적), 연결 리스트(순차적 x)

비선형 구조
1. 트리
2. 그래프
방향 그래프 : 선에 방향이 있는 그래프로 n개의 정점으로 구성된 최대 간선 수는  n(n-1)
무방향 그래프 : 선에 방향이 없는 그래프로 n개의 정점으로 구성된 최대 간선 수는  n(n-1)/2

데이터베이스
공용 데이터 : 공동으로 소유하고 유지하는 자료
통합된 데이터 : 자료의 중복을 최대한 배제한 데이터의 모임
운영 데이터 : 고유한 업무를 수행하는 데 없어서는 안 될 자료
저장된 데이터 : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료.

DBMS : 데이터베이스를 관리해주는 소프트웨어
정의 기능 : DDL (데이터를 정의하거나 변경 또는 삭제할때 사용) CREATE ALTER DROP RENAME COMMIT TRUNCATE
조작 기능 : DML (인터페이스 수단을 제공) SELECT INSERT UPDATE DELETE
제어 기능 : DCL (무결성, 보안, 권한, 병행 제어) REVOKE, GRANT

데이터 접속
SQL Mapping : 프로그래밍 코드 내 SQL을 직접 입력해 DBMS 데이터에 접속하는 기술 ex) JDBC, ODBC, Mybatis
ORM Object Relational Mapping : 객체와 관계형데이터베이스의 데이터를 연결하는 기술 ex) JPA,Hibernate,Django

트랜잭션
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위.
한꺼번에 모두 수행되어야 할 일련의 연산들

COMMIT : 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어.

ROLLBACK : 트랜잭션 처리가 비정상적으로 종료되어 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산.

트랜잭션의 특성
1. 원자성 Atomicity: 트랜잭션 연산을 DB 모두에 반영 또는 반영하지 말아야 함. (All or Nothing) 
2. 일관성 Consistency : 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지.
3. 독립성 Isolation : 둘 이상 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭이 불가하다.
4. 영속성 Durability : 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영.

프로시저(Procedure) : 호출을 통해 실행되어 미리 저장해 놓은 SQL작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환 하지 않음.

트리거(Trigger) : 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 자동 수행 (특정한 이벤트가 발생할때 자동으로 실행되는 것)

통합 개발 환경 (IDE Integrated Development Environment)
개발에 필요한 환경, 즉 에디터, 컴파일러, 디버거 등 다양한 툴을 하나의 인터페이스로 통합해 제공하는 것
ex ) 이클립스, 비주얼 스튜디오, 엑스코드, 안드로이드 스튜디오, IDEA

빌드 자동화 도구
소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어\
1. Ant : 아파치에서 개발한 소프트웨어, XML 기반, 자바 프로젝트 빌드 자동화 도구, 규칙이나 표준이 없어 개발자가 모든 것을 정의,
스크립트 재사용이 어려움.
2. Maven : Ant대용으로 만듬. 컴파일과 빌드를 동시에 수행 가능, 의존성(Dependency)을 설정하여 라이브러리 관리.
3. Gradle : Ant와 Maven을 보완해 개발됨, 안드로이드의 공식 빌드 도구, Dependency 사용, 다양한 언어 빌드 가능, 실행할 명령들을 모아 태스크를 만든 후 태스크 단위로 실행함. 빌드 캐시 기능 -> 빌드의 속도 향상.
4. Jenkins : JAVA기반의 오픈 소스 형태의 빌드 자동화 도구. 서블릿 컨테이너에서 실행, 대부분의 형상 관리 도구와 연동 가능.
친숙한 Web GUI 제공. 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능.

소프트웨어 패키지
모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것. 개발자가 아닌 사용자 중심으로 진행.

패키징 작업 순서
기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 적용 -> 패키징 변경 개선 -> 배포

소프트웨어 패키징 도구 활용시 고려사항
1. 사용자에게 배포되는 SW때문에 보안 고려
2. 사용자 편의성을 위해 복잡성 및 비효율성 문제 고려 
3. 제품 SW종류에 적합한 암호화 알고리즘 적용.
4. 다양한 이기종 연동 고려.

디지털 저작권 관리 DRM Digital Right Management
DRM의 흐름
1. 컨텐츠 제공자, 분배자, 소비자
2. 패키저
3. 클리어링 하우스
4. DRM 컨트롤러
5. 보안 컨테이너

DRM의 기술요소
1. 암호화
2. 키 관리
3. 식별기술
4. 저작권표현
5. 암호화 파일 생성
6. 정책 관리
7. 크랙 방지
8. 인증

소프트웨어 패키징의 형상 관리 SCM Software Configuration Management
형상관리 : 소프트웨어 개발 과정에서 소프트웨어의 변경 사항을 관리. 개발의 전 단계에 적용되는 활동, 유지보수 단계에서도 수행.

중요성
1. 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있음
2. 소프트웨어에 대한 무절제한 변경 방지
3. 진행 정도를 확인하기 위한 기준.

기능
1. 형상 식별
2. 형상 통제
3. 형상 감사
4. 형상 기록
5. 버전 제어

등록 과정
가져오기 Import -> 인출 Check Out -> 예치 Commit -> 동기화 Update -> 차이 Diff

형상관리 역할
1. 이전 리비전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용
2. 불필요한 사용자의 소스 수정 제한
3. 동일 프로젝트에 대해 여러 개발자 동시 개발 가능

버전 관리 도구
1. 공유 폴더 방식 ex) SCCS, RCS, PVCS, QVCS
2. 클라이언트/서버 방식 ex) CVS, SVN(Subversion)
3. 분산 저장소 방식 ex) Git, Bitkeeper

어플리케이션 테스트의 개념
1. 결함을 찾아내는 행위
2. 고객의 요구사항을 만족시키는지 확인
3. 기능을 정확히 수행하는지 검증

기본 원리
1. 파레토의 법칙 : 소프트웨어 테스트의 오류 80%는 전체의 20%에서 발견된다.
2. 살충제 패러독스 : 동일 테스트 케이스로 동일 테스트 반복 시 결함이 발견되지 않는 현상
3. 오류-부재의 궤변 : 결함이 없어도 요구사항을 만족하지 못하면 해당 소프트웨어의 품질이 높다고 할 수 없다.


테스트의 분류
정적 테스트 : 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 ex) 워크 스루, 인스펙션, 코드 검사, 동료 검토
동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트 ex) 화이트박스(소스코드 오류 분석), 블랙박스(어플리케이션에서 오류 분석)

기반에 따른 테스트
명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만듬. ex) 동등 분할, 경계값 분석(블랙박스 테스트)
구조 기반 테스트 : 내부의 논리 흐름에 따라 테스트 케이스 작성하고 확인 ex) 구문 기반, 결정 기반, 조건 기반(화이트박스 테스트)
경험 기반 테스트 : 테스터의 경험을 기반으로 테스트 ex) 에러 추정, 체크 리스트, 탐색적 테스팅

시각에 따른 테스트
검증 테스트 : 개발자의 시각에서 제품의 생산 과정 테스트 ex) 단위 테스트, 통합 테스트, 시스템 테스트
확인 테스트 : 사용자의 시각에서 생상된 제품의 결과를 테스트 ex) 인수 테스트 (알파 테스트, 베타 테스트)

화이트박스 테스트
모듈 안의 내용(작동)을 직접 볼 수 있고 내부의 논리적인 모든 경로를 테스트해 테스트 케이스를 설계
소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행하고 선택 반복 등의 부분들을 수행함으로써 논리적 경로 점검

테스트의 종류
기초 경로 검사 : 대표적인 화이트박스 테스트 기법, 테스트 측정 결과는 실행 경로의 기초를 정의하는 지침으로 사용.
제어 구조 검사
1. 조건 검사 : 논리적 조건 테스트
2. 루프 검사 : 반복 구조에 맞춰 테스트
3. 데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 테스트

블랙박스 테스트
모듈 안의 내용(작동)을 알 수 없고 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 기능 테스트, 인터페이스에서 실시됨.

테스트의 종류
1. 동치 분할 검사
2. 경계값 분석
3. 원인-효과 그래프 검사
4. 비교 검사 : 동일한 테스트 자료를 제공해 동일한 결과가 출력 되는지 확인.
5. 오류 예측 검사 : 다른 블랙박스 테스트 기법으로 찾아낼 수 없는 오류를 찾아내는 기법 데이터 확인 검사

개발 단계에 따른 어플리케이션 테스트
1. 단위 테스트 : 코딩 직후 모듈이나 컴포넌트에 초점을 맞춰 테스트, 주로 구조 기반 테스트를 시행
2. 통합 테스트 : 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트 ex) 빅뱅 테스트,
상향식 테스트(Driver, Cluster), 하향식 테스트 (Stub)
3. 시스템 테스트 : 개발된 소프트웨어가 컴퓨터 시스템에서 완벽하게 수행되는가 점검하는 테스트
4. 인수 테스트 : 사용자의 요구사항을 충족하는지에 중점을 두는 테스트 ex) 알파테스트, 베타테스트
알파 테스트 : 통제된 환경에서 사용자가 개발자와 함께 확인하는 테스트
베타 테스트 : 통제되지 않은 환경에서 여러 명의 사용자가 행하는 테스트 기법 -> 게임 베타 테스트 생각하면 쉬움.

통합 테스트
1.상향식 통합 테스트
하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법, 제어 모듈과 관련된 종속 모됼의 그룹인 클러스터 필요
하위모듈을 클러스터로 결합 -> 더미 모듈인 드라이버 작성 -> 클러스터 단위로 테스트 -> 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합 -> 드라이버는 실제 모듈로 대체됨.

2. 하향식 통합 테스트
상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법. 깊이 우선, 넓이 우선 통합법 사용.
테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음. 상위모듈에서는 테스트 케이스 사용하기 어려움.
주요 제어 모듈은 작성된 프로그램을 사용. 제어 모듈의 종속 모듈은 스텁(Stub)으로 대체
통합 방식에 따라 하위 모듈인 Stub들이 한번에 하나씩 실제 모듈로 교체됨 -> 모듈이 통합될 때마다 테스트 실시 -> 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

3. 혼합식 통합 테스트
하위 수준에서는 상향식, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식
샌드위치식 통합 테스트 방식

테스트 케이스
사용자의 요구사항을 정확하게 준수했는지 설계된 입력값, 실행조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서

어플리케이션 성능 분석
1. 처리량 : 어플리케이션이 처리하는 일의 양
2. 응답 시간 : 요청을 전달한 시간부터 응답이 도착할 때 까지 걸린 시간
3. 경과 시간 : 작업을 의뢰한 시간부터 처리가 완료될 때 까지 걸린 시간
4. 자원 사용률 : CPU사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

어플리케이션 성능 저하 원인 분석
1. DB에 필요 이상의 많은 데이터를 요청한 경우
2. 커넥션 풀(connection pool)의 크기를 너무 작거나 크게 설정한 경우
3. JDBC나 ODBC 같은 미들웨어를 사용한 후 종료하지 않아 연결 누수가 발생한 경우
4. 대량의 파일을 업로드하거나 다운로드해 처리 시간이 길어진 경우

클린 코드 작성 원칙
가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

소스 코드 품질분석 도구의 종류
정적 분석 도구 : pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna
동적 분석 도구 : Avalanche, Valgrind

EAI Enterprise Application Integration
기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
1. 포인트 투 포인트(point to point) : 점 대 점으로 연결하는 방식, 변경 및 재사용 어려움
2. Hub & Spoke : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식, 확장 및 유지보수는 용이하지만 허브 장애 발생시 시스템 전체에 영향을 미침.
3. Message Bus : 어플리케이션 사이에 미들웨어를 둬 처리하는 방식, 확장성이 뛰어나며 대용량 처리 가능
4. Hybrid : Hub&Spoke와 Message Bus의 혼합 방식, 데이터 병목현상을 최소화 할 수 있다.

ESB Enterprise Service Bus
서비스 중심의 통합을 지향하고 결합도를 약하게 유지함. 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

데이터 통신을 이용한 인터페이스 구현
어플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신 측에서 파싱해 해석하는 방식
1. JSON JavaScript Object Notation : 속성-값 쌍으로 이뤄진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
2. XML eXtensible Markup Langauge : 특수한 목적을 갖는 마크업 언어를 만드는데 사용되는 다목적 마크업 언어. HTML의 문법과 SGML의 복잡함을 해결하기 위해 개발됨  

인터페이스 구현 검증 도구
1. xUnit  : 다양한 언어를 지원하는 단위 테스트 프레임워크
2. STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 프레임워크
3. FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 프레임 워크
4. NTAF : STAF의 장점인 재사용 및 확장성과 FitnNesse의 장점인 협업 가능을 통합한 NHN의 테스트 자동화 프레임워크
5. Selenium : 다양한 브라우저 및 개발 언어를 지원하는 웹 어플리케이션 테스트 프레임 워크
6. watir : Ruby 언어를 사용하는 어플리케이션 테스트 프레임워크
